--- ffms2-2.20/configure.ac~	2016-03-22 18:01:21.000000000 +0100
+++ ffms2-2.20/configure.ac	2016-03-22 18:02:57.590572584 +0100
@@ -156,7 +156,7 @@
                 avcodec_register_all();
                 swscale_version();
                 #ifdef FFMS_USE_FFMPEG_COMPAT
-                int bogus = CODEC_ID_G2M;
+                int bogus = AV_CODEC_ID_G2M;
                 (void) bogus;
                 #endif
             ]])], [eval $1=yes], [eval $1=no])
--- ffms2-2.20/src/core/videosource.h~	2014-06-20 17:09:10.000000000 +0200
+++ ffms2-2.20/src/core/videosource.h	2016-03-22 18:04:27.388385707 +0100
@@ -39,19 +39,19 @@
 
 	int LastFrameHeight;
 	int LastFrameWidth;
-	PixelFormat LastFramePixelFormat;
+	AVPixelFormat LastFramePixelFormat;
 
 	int TargetHeight;
 	int TargetWidth;
-	std::vector<PixelFormat> TargetPixelFormats;
+	std::vector<AVPixelFormat> TargetPixelFormats;
 	int TargetResizer;
 
-	PixelFormat OutputFormat;
+	AVPixelFormat OutputFormat;
 	AVColorRange OutputColorRange;
 	AVColorSpace OutputColorSpace;
 
 	bool InputFormatOverridden;
-	PixelFormat InputFormat;
+	AVPixelFormat InputFormat;
 	AVColorRange InputColorRange;
 	AVColorSpace InputColorSpace;
 
@@ -89,9 +89,9 @@
 	virtual FFMS_Frame *GetFrame(int n) = 0;
 	void GetFrameCheck(int n);
 	FFMS_Frame *GetFrameByTime(double Time);
-	void SetOutputFormat(const PixelFormat *TargetFormats, int Width, int Height, int Resizer);
+	void SetOutputFormat(const AVPixelFormat *TargetFormats, int Width, int Height, int Resizer);
 	void ResetOutputFormat();
-	void SetInputFormat(int ColorSpace, int ColorRange, PixelFormat Format);
+	void SetInputFormat(int ColorSpace, int ColorRange, AVPixelFormat Format);
 	void ResetInputFormat();
 };
 
--- ffms2-2.20/src/core/videosource.cpp~	2014-06-20 17:09:10.000000000 +0200
+++ ffms2-2.20/src/core/videosource.cpp	2016-03-22 18:05:31.439198279 +0100
@@ -55,7 +55,7 @@
 	if (LastFrameWidth != CodecContext->width || LastFrameHeight != CodecContext->height || LastFramePixelFormat != CodecContext->pix_fmt) {
 		if (TargetHeight > 0 && TargetWidth > 0 && !TargetPixelFormats.empty()) {
 			if (!InputFormatOverridden) {
-				InputFormat = PIX_FMT_NONE;
+				InputFormat = AV_PIX_FMT_NONE;
 				InputColorSpace = AVCOL_SPC_UNSPECIFIED;
 				InputColorRange = AVCOL_RANGE_UNSPECIFIED;
 			}
@@ -129,18 +129,18 @@
 
 	LastFrameHeight = -1;
 	LastFrameWidth = -1;
-	LastFramePixelFormat = PIX_FMT_NONE;
+	LastFramePixelFormat = AV_PIX_FMT_NONE;
 
 	TargetHeight = -1;
 	TargetWidth = -1;
 	TargetResizer = 0;
 
-	OutputFormat = PIX_FMT_NONE;
+	OutputFormat = AV_PIX_FMT_NONE;
 	OutputColorSpace = AVCOL_SPC_UNSPECIFIED;
 	OutputColorRange = AVCOL_RANGE_UNSPECIFIED;
 
 	InputFormatOverridden = false;
-	InputFormat = PIX_FMT_NONE;
+	InputFormat = AV_PIX_FMT_NONE;
 	InputColorSpace = AVCOL_SPC_UNSPECIFIED;
 	InputColorRange = AVCOL_RANGE_UNSPECIFIED;
 	if (Threads < 1)
@@ -151,7 +151,7 @@
 	LastDecodedFrame = av_frame_alloc();
 
 	// Dummy allocations so the unallocated case doesn't have to be handled later
-	avpicture_alloc(&SWSFrame, PIX_FMT_GRAY8, 16, 16);
+	avpicture_alloc(&SWSFrame, AV_PIX_FMT_GRAY8, 16, 16);
 
 	Index.AddRef();
 }
@@ -172,33 +172,33 @@
 	return GetFrame(Frame);
 }
 
-static AVColorRange handle_jpeg(PixelFormat *format) {
+static AVColorRange handle_jpeg(AVPixelFormat *format) {
 	switch (*format) {
-		case PIX_FMT_YUVJ420P: *format = PIX_FMT_YUV420P; return AVCOL_RANGE_JPEG;
-		case PIX_FMT_YUVJ422P: *format = PIX_FMT_YUV422P; return AVCOL_RANGE_JPEG;
-		case PIX_FMT_YUVJ444P: *format = PIX_FMT_YUV444P; return AVCOL_RANGE_JPEG;
-		case PIX_FMT_YUVJ440P: *format = PIX_FMT_YUV440P; return AVCOL_RANGE_JPEG;
+		case AV_PIX_FMT_YUVJ420P: *format = AV_PIX_FMT_YUV420P; return AVCOL_RANGE_JPEG;
+		case AV_PIX_FMT_YUVJ422P: *format = AV_PIX_FMT_YUV422P; return AVCOL_RANGE_JPEG;
+		case AV_PIX_FMT_YUVJ444P: *format = AV_PIX_FMT_YUV444P; return AVCOL_RANGE_JPEG;
+		case AV_PIX_FMT_YUVJ440P: *format = AV_PIX_FMT_YUV440P; return AVCOL_RANGE_JPEG;
 		default:                                          return AVCOL_RANGE_UNSPECIFIED;
 	}
 }
 
-void FFMS_VideoSource::SetOutputFormat(const PixelFormat *TargetFormats, int Width, int Height, int Resizer) {
+void FFMS_VideoSource::SetOutputFormat(const AVPixelFormat *TargetFormats, int Width, int Height, int Resizer) {
 	TargetWidth = Width;
 	TargetHeight = Height;
 	TargetResizer = Resizer;
 	TargetPixelFormats.clear();
-	while (*TargetFormats != PIX_FMT_NONE)
+	while (*TargetFormats != AV_PIX_FMT_NONE)
 		TargetPixelFormats.push_back(*TargetFormats++);
-	OutputFormat = PIX_FMT_NONE;
+	OutputFormat = AV_PIX_FMT_NONE;
 
 	ReAdjustOutputFormat();
 	OutputFrame(DecodeFrame);
 }
 
-void FFMS_VideoSource::SetInputFormat(int ColorSpace, int ColorRange, PixelFormat Format) {
+void FFMS_VideoSource::SetInputFormat(int ColorSpace, int ColorRange, AVPixelFormat Format) {
 	InputFormatOverridden = true;
 
-	if (Format != PIX_FMT_NONE)
+	if (Format != AV_PIX_FMT_NONE)
 		InputFormat = Format;
 	if (ColorRange != AVCOL_RANGE_UNSPECIFIED)
 		InputColorRange = (AVColorRange)ColorRange;
@@ -212,7 +212,7 @@
 }
 
 void FFMS_VideoSource::DetectInputFormat() {
-	if (InputFormat == PIX_FMT_NONE)
+	if (InputFormat == AV_PIX_FMT_NONE)
 		InputFormat = CodecContext->pix_fmt;
 
 	AVColorRange RangeFromFormat = handle_jpeg(&InputFormat);
@@ -239,7 +239,7 @@
 	DetectInputFormat();
 
 	OutputFormat = FindBestPixelFormat(TargetPixelFormats, InputFormat);
-	if (OutputFormat == PIX_FMT_NONE) {
+	if (OutputFormat == AV_PIX_FMT_NONE) {
 		ResetOutputFormat();
 		throw FFMS_Exception(FFMS_ERROR_SCALING, FFMS_ERROR_INVALID_ARGUMENT,
 			"No suitable output format found");
@@ -287,7 +287,7 @@
 	TargetHeight = -1;
 	TargetPixelFormats.clear();
 
-	OutputFormat = PIX_FMT_NONE;
+	OutputFormat = AV_PIX_FMT_NONE;
 	OutputColorSpace = AVCOL_SPC_UNSPECIFIED;
 	OutputColorRange = AVCOL_RANGE_UNSPECIFIED;
 
@@ -296,7 +296,7 @@
 
 void FFMS_VideoSource::ResetInputFormat() {
 	InputFormatOverridden = false;
-	InputFormat = PIX_FMT_NONE;
+	InputFormat = AV_PIX_FMT_NONE;
 	InputColorSpace = AVCOL_SPC_UNSPECIFIED;
 	InputColorRange = AVCOL_RANGE_UNSPECIFIED;
 
@@ -318,9 +318,9 @@
 	VP.ColorSpace = CodecContext->colorspace;
 	VP.ColorRange = CodecContext->color_range;
 	// these pixfmt's are deprecated but still used
-	if (CodecContext->pix_fmt == PIX_FMT_YUVJ420P ||
-		CodecContext->pix_fmt == PIX_FMT_YUVJ422P ||
-		CodecContext->pix_fmt == PIX_FMT_YUVJ444P
+	if (CodecContext->pix_fmt == AV_PIX_FMT_YUVJ420P ||
+		CodecContext->pix_fmt == AV_PIX_FMT_YUVJ422P ||
+		CodecContext->pix_fmt == AV_PIX_FMT_YUVJ444P
 		)
 		VP.ColorRange = AVCOL_RANGE_JPEG;
 
--- ffms2-2.20/src/core/videoutils.h~	2014-06-20 17:09:10.000000000 +0200
+++ ffms2-2.20/src/core/videoutils.h	2016-03-22 18:06:41.360081076 +0100
@@ -35,7 +35,7 @@
 
 // swscale and pp-related functions
 int64_t GetSWSCPUFlags();
-SwsContext *GetSwsContext(int SrcW, int SrcH, PixelFormat SrcFormat, int SrcColorSpace, int SrcColorRange, int DstW, int DstH, PixelFormat DstFormat, int DstColorSpace, int DstColorRange, int64_t Flags);
+SwsContext *GetSwsContext(int SrcW, int SrcH, AVPixelFormat SrcFormat, int SrcColorSpace, int SrcColorRange, int DstW, int DstH, AVPixelFormat DstFormat, int DstColorSpace, int DstColorRange, int64_t Flags);
 AVColorSpace GetAssumedColorSpace(int Width, int Height);
 
 // timebase-related functions
@@ -43,6 +43,6 @@
 void CorrectTimebase(FFMS_VideoProperties *VP, FFMS_TrackTimeBase *TTimebase);
 
 // our implementation of avcodec_find_best_pix_fmt()
-PixelFormat FindBestPixelFormat(const std::vector<PixelFormat> &Dsts, PixelFormat Src);
+AVPixelFormat FindBestPixelFormat(const std::vector<AVPixelFormat> &Dsts, AVPixelFormat Src);
 
 void RegisterCustomParsers();
--- ffms2-2.20/src/core/videoutils.cpp~	2014-06-20 17:09:10.000000000 +0200
+++ ffms2-2.20/src/core/videoutils.cpp	2016-03-22 18:07:35.707431208 +0100
@@ -29,7 +29,7 @@
 #include <libavutil/opt.h>
 }
 
-SwsContext *GetSwsContext(int SrcW, int SrcH, PixelFormat SrcFormat, int SrcColorSpace, int SrcColorRange, int DstW, int DstH, PixelFormat DstFormat, int DstColorSpace, int DstColorRange, int64_t Flags) {
+SwsContext *GetSwsContext(int SrcW, int SrcH, AVPixelFormat SrcFormat, int SrcColorSpace, int SrcColorRange, int DstW, int DstH, AVPixelFormat DstFormat, int DstColorSpace, int DstColorRange, int64_t Flags) {
 	Flags |= SWS_FULL_CHR_H_INT | SWS_FULL_CHR_H_INP | SWS_ACCURATE_RND | SWS_BITEXACT;
 	SwsContext *Context = sws_alloc_context();
 	if (!Context) return 0;
@@ -123,10 +123,8 @@
 	cUNUSABLE
 };
 
-static BCSType GuessCSType(PixelFormat p) {
+static BCSType GuessCSType(AVPixelFormat p) {
 	// guessing the colorspace type from the name is kinda hackish but libav doesn't export this kind of metadata
-	if (av_pix_fmt_desc_get(p)->flags & PIX_FMT_HWACCEL)
-		return cUNUSABLE;
 	const char *n = av_get_pix_fmt_name(p);
 	if (strstr(n, "gray") || strstr(n, "mono") || strstr(n, "y400a"))
 		return cGRAY;
@@ -138,7 +138,7 @@
 }
 
 struct LossAttributes {
-	PixelFormat Format;
+	AVPixelFormat Format;
 	int ChromaUndersampling;
 	int ChromaOversampling;
 	int DepthDifference;
@@ -153,7 +153,7 @@
 	return depth + 1;
 }
 
-static LossAttributes CalculateLoss(PixelFormat Dst, PixelFormat Src) {
+static LossAttributes CalculateLoss(AVPixelFormat Dst, AVPixelFormat Src) {
 	const AVPixFmtDescriptor &SrcDesc = *av_pix_fmt_desc_get(Src);
 	const AVPixFmtDescriptor &DstDesc = *av_pix_fmt_desc_get(Dst);
 	BCSType SrcCS = GuessCSType(Src);
@@ -182,15 +182,15 @@
 	return Loss;
 }
 
-PixelFormat FindBestPixelFormat(const std::vector<PixelFormat> &Dsts, PixelFormat Src) {
+AVPixelFormat FindBestPixelFormat(const std::vector<AVPixelFormat> &Dsts, AVPixelFormat Src) {
 	// some trivial special cases to make sure there's as little conversion as possible
 	if (Dsts.empty())
-		return PIX_FMT_NONE;
+		return AV_PIX_FMT_NONE;
 	if (Dsts.size() == 1)
 		return Dsts[0];
 
 	// is the input in the output?
-	std::vector<PixelFormat>::const_iterator i = std::find(Dsts.begin(), Dsts.end(), Src);
+	std::vector<AVPixelFormat>::const_iterator i = std::find(Dsts.begin(), Dsts.end(), Src);
 	if (i != Dsts.end())
 		return Src;
 
--- ffms2-2.20/src/core/ffms.cpp~	2014-06-20 17:09:10.000000000 +0200
+++ ffms2-2.20/src/core/ffms.cpp	2016-03-22 18:08:09.401187196 +0100
@@ -216,7 +216,7 @@
 FFMS_API(int) FFMS_SetOutputFormatV2(FFMS_VideoSource *V, const int *TargetFormats, int Width, int Height, int Resizer, FFMS_ErrorInfo *ErrorInfo) {
 	ClearErrorInfo(ErrorInfo);
 	try {
-		V->SetOutputFormat(reinterpret_cast<const PixelFormat *>(TargetFormats), Width, Height, Resizer);
+		V->SetOutputFormat(reinterpret_cast<const AVPixelFormat *>(TargetFormats), Width, Height, Resizer);
 	} catch (FFMS_Exception &e) {
 		return e.CopyOut(ErrorInfo);
 	}
@@ -230,7 +230,7 @@
 FFMS_API(int) FFMS_SetInputFormatV(FFMS_VideoSource *V, int ColorSpace, int ColorRange, int Format, FFMS_ErrorInfo *ErrorInfo) {
 	ClearErrorInfo(ErrorInfo);
 	try {
-		V->SetInputFormat(ColorSpace, ColorRange, static_cast<PixelFormat>(Format));
+		V->SetInputFormat(ColorSpace, ColorRange, static_cast<AVPixelFormat>(Format));
 	} catch (FFMS_Exception &e) {
 		return e.CopyOut(ErrorInfo);
 	}
--- ffms2-2.20/src/vapoursynth/vapoursource.cpp~	2014-06-20 17:09:10.000000000 +0200
+++ ffms2-2.20/src/vapoursynth/vapoursource.cpp	2016-03-22 18:19:10.716042796 +0100
@@ -48,7 +48,7 @@
 
 static int GetNumPixFmts() {
 	int n = 0;
-	while (av_get_pix_fmt_name((PixelFormat)n))
+	while (av_get_pix_fmt_name((AVPixelFormat)n))
 		n++;
 	return n;
 }
@@ -63,7 +63,7 @@
 static int GetColorFamily(const AVPixFmtDescriptor &desc) {
 	if (desc.nb_components == 1)
 		return cmGray;
-	else if (desc.flags & PIX_FMT_RGB)
+	else if (desc.flags & AV_PIX_FMT_FLAG_RGB)
 		return cmRGB;
 	else
 		return cmYUV;
@@ -82,7 +82,7 @@
 				&& desc.log2_chroma_h == f->subSamplingH)
 				return i;
 		}
-		return PIX_FMT_NONE;
+		return AV_PIX_FMT_NONE;
 	} else {
 		int colorfamily = cmYUV;
 		if (av_pix_fmt_desc_get((AVPixelFormat) id)->nb_components == 1)
@@ -239,12 +239,12 @@
 	for (int i = 0; i < npixfmt; i++)
 		if (IsRealPlanar(*av_pix_fmt_desc_get((AVPixelFormat) i)))
 			TargetFormats.push_back(i);
-	TargetFormats.push_back(PIX_FMT_NONE);
+	TargetFormats.push_back(AV_PIX_FMT_NONE);
 
-	int TargetPixelFormat = PIX_FMT_NONE;
+	int TargetPixelFormat = AV_PIX_FMT_NONE;
 	if (ConvertToFormat != pfNone) {
 		TargetPixelFormat = formatConversion(ConvertToFormat, true, core, vsapi);
-		if (TargetPixelFormat == PIX_FMT_NONE)
+		if (TargetPixelFormat == AV_PIX_FMT_NONE)
 			throw std::runtime_error(std::string("Source: Invalid output colorspace specified"));
 
 		TargetFormats.clear();
